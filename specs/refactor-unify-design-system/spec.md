# Feature Specification: スペーシングの統一化

**Feature Branch**: `refactor/unify-design-system`
**Created**: 2026-01-09
**Status**: Draft
**Input**: 現在のコードはほとんどすべてのtailwindの値(px-2などの決め方)がコードに直書きになっています。これはUIの統一感を失わせ、拡張を難しくする原因です。デザインシステムを構築することでこの問題を解決したいです。まずはデザインはそのままに統一感のないpaddingやmarginなどを統一してください。その際はレスポンシブを考慮してください。proseを含め、全てのコンポーネントを対象にします

## User Scenarios & Testing *(mandatory)*

### User Story 1 - デザインの見た目を維持したままスペーシングを統一 (Priority: P1)

開発者として、既存のUIの見た目を変更せずに、ハードコードされたスペーシング値をデザイントークンに置き換えたい。これにより、将来のデザイン変更が容易になる。

**Why this priority**: これがこのリファクタリングの核心であり、見た目を壊さないことがユーザー体験を維持する上で最も重要。

**Independent Test**: 各ページをリファクタリング前後でスクリーンショット比較し、視覚的な差異がないことを確認できる。

**Acceptance Scenarios**:

1. **Given** 既存のコンポーネントにハードコードされたスペーシング値がある, **When** デザイントークンに置き換える, **Then** UIの見た目は変化しない
2. **Given** 複数の箇所で異なるmargin/paddingの値が使用されている, **When** 統一されたトークンに置き換える, **Then** 既存のレイアウトが維持される

---

### User Story 2 - レスポンシブデザインの維持 (Priority: P1)

開発者として、モバイル・タブレット・デスクトップの各ブレークポイントでのレイアウトを維持しながらスペーシングを統一したい。

**Why this priority**: レスポンシブ対応はブログの基本要件であり、どのデバイスでも適切に表示されることが必須。

**Independent Test**: 各ブレークポイント（モバイル、タブレット、デスクトップ）でページを表示し、レイアウトが適切に維持されていることを確認できる。

**Acceptance Scenarios**:

1. **Given** モバイル画面幅（< 640px）でページを表示, **When** リファクタリング後のコードを使用, **Then** リファクタリング前と同じレイアウトが表示される
2. **Given** タブレット画面幅（640px - 1024px）でページを表示, **When** リファクタリング後のコードを使用, **Then** リファクタリング前と同じレイアウトが表示される
3. **Given** デスクトップ画面幅（> 1024px）でページを表示, **When** リファクタリング後のコードを使用, **Then** リファクタリング前と同じレイアウトが表示される

---

### User Story 3 - proseコンテンツのスペーシング統一 (Priority: P2)

開発者として、Markdown記事のproseスタイルにおけるスペーシングもデザイントークンで管理したい。これにより、記事の読みやすさを一貫して制御できる。

**Why this priority**: ブログの主要コンテンツは記事であり、proseスタイルの統一は重要だが、コンポーネントのスペーシング統一の後に対応可能。

**Independent Test**: Markdown記事ページを表示し、見出し・段落・リストなどの間隔が適切に維持されていることを確認できる。

**Acceptance Scenarios**:

1. **Given** Markdown記事が表示されている, **When** proseスタイルのスペーシングをトークン化, **Then** 見出し間、段落間の間隔が変わらない
2. **Given** コードブロックを含む記事がある, **When** proseスタイルを適用, **Then** コードブロックの余白が適切に維持される

---

### User Story 4 - スペーシングトークンの定義 (Priority: P2)

開発者として、統一されたスペーシングスケール（4px刻みなど）を定義し、プロジェクト全体で再利用できるようにしたい。

**Why this priority**: トークンの定義は他のすべての作業の基盤となるが、既存の値を分析してから定義する必要がある。

**Independent Test**: 定義されたトークンを使用して新しいコンポーネントを作成し、既存のデザインと調和することを確認できる。

**Acceptance Scenarios**:

1. **Given** スペーシングトークンが定義されている, **When** 新しいコンポーネントを追加, **Then** 既存のコンポーネントと一貫した間隔で配置できる
2. **Given** セマンティックなトークン名（section-spacing, card-padding等）がある, **When** 開発者がスペーシングを適用, **Then** 適切なトークンを選択しやすい

---

### Edge Cases

- 既存のマジックナンバーが意図的に使われている場合（視覚的なバランス調整など）
- 同じ役割のスペーシングが異なる値で定義されている場合の統一方針
- レスポンシブで大きく異なるスペーシングが設定されている場合のトークン化方法

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: システムは、既存のすべてのコンポーネントのスペーシング値を分析し、使用パターンを特定できること
- **FR-002**: システムは、ハードコードされたスペーシング値（px-2, mt-4等）をセマンティックなトークンに置き換えられること
- **FR-003**: システムは、置き換え後もピクセル単位で同一の見た目を維持すること
- **FR-004**: システムは、モバイル・タブレット・デスクトップの各ブレークポイントでのスペーシングを個別に管理できること
- **FR-005**: システムは、proseクラスを含むMarkdownコンテンツのスペーシングを一元管理できること
- **FR-006**: システムは、セマンティックなトークン名（例：spacing-section, spacing-card）を用いてスペーシングを定義できること

### Key Entities

- **Spacing Token**: スペーシングの値を表す抽象的な単位。名前（セマンティック）、値（ピクセル）、適用コンテキスト（コンポーネント種別）を持つ
- **Breakpoint**: レスポンシブデザインの境界点。各ブレークポイントで異なるスペーシング値を持つことができる
- **Component**: スペーシングが適用されるUI要素。スペーシングトークンを参照する

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: リファクタリング後、すべてのページで視覚的な差異がないこと（スクリーンショット比較で100%一致）
- **SC-002**: ハードコードされたスペーシング値の90%以上がデザイントークンに置き換えられること
- **SC-003**: すべてのコンポーネント（prose含む）が統一されたスペーシングトークンを使用すること
- **SC-004**: 3つのブレークポイント（モバイル、タブレット、デスクトップ）すべてでレイアウトが正常に表示されること

## Assumptions

- 既存のスペーシング値は、4pxの倍数を基本スケールとして統一可能である
- 現在使用されているブレークポイントはsm(640px), md(768px), lg(1024px), xl(1280px)である
- proseスタイルはTailwindのtypographyプラグインを使用している
- デザインの見た目を変えないことが最優先であり、理想的なスペーシングへの変更は別フェーズで行う

## Scope Boundaries

### In Scope
- すべてのReactコンポーネントのmargin/paddingの統一
- proseクラスのスペーシング統一
- レスポンシブブレークポイントの考慮
- スペーシングトークンの定義

### Out of Scope
- 色やフォントサイズのトークン化（別フィーチャーで対応）
- デザインの改善や変更（見た目は現状維持）
- アニメーションやトランジションの変更
